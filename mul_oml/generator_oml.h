/*
 * This file was automatically generated by oml2-scaffold V2.11.0rc.3-6bff-dirty
 * for generator version 1.0.0.
 * Please do not edit.
 */

#ifndef GENERATOR_OML_H
#define GENERATOR_OML_H

#ifdef __cplusplus
extern "C" {
#endif

/* Define HUGE etc.. */
#include <math.h>
/* Get size_t and NULL from <stddef.h> */
#include <stddef.h>

#include <oml2/omlc.h>

typedef struct {
  OmlMP *switch;
  OmlMP *flow;

} oml_mps_t;


#ifdef OML_FROM_MAIN
/*
 * Only declare storage once, usually from the main
 * source, where OML_FROM_MAIN is defined
 */

static OmlMPDef oml_switch_def[] = {
  {"list", OML_STRING_VALUE},
  {NULL, (OmlValueT)0}
};

static OmlMPDef oml_flow_def[] = {
  {"entries", OML_STRING_VALUE},
  {NULL, (OmlValueT)0}
};

static oml_mps_t g_oml_mps_storage;
oml_mps_t* g_oml_mps_generator = &g_oml_mps_storage;

static inline void
oml_register_mps(void)
{
  g_oml_mps_generator->switch = omlc_add_mp("switch", oml_switch_def);
  g_oml_mps_generator->flow = omlc_add_mp("flow", oml_flow_def);

}

#else
/*
 * Not included from the main source, only declare the global pointer
 * to the MPs and injection helpers.
 */

extern oml_mps_t* g_oml_mps_generator;

#endif /* OML_FROM_MAIN */

static inline int
oml_inject_switch(OmlMP *mp, const char *list)
{
  int ret = -1;

  OmlValueU v[1];
  omlc_zero_array(v, 1);

  omlc_set_string(v[0], list);

  ret = omlc_inject(mp, v);

  omlc_reset_string(v[0]);
  return ret;
}

static inline int
oml_inject_flow(OmlMP *mp, const char *entries)
{
  int ret = -1;

  OmlValueU v[1];
  omlc_zero_array(v, 1);

  omlc_set_string(v[0], entries);

  ret = omlc_inject(mp, v);

  omlc_reset_string(v[0]);
  return ret;
}


/* Compatibility with old applications */
#ifndef g_oml_mps
# define g_oml_mps	g_oml_mps_generator
#endif

#ifdef __cplusplus
}
#endif

#endif /* GENERATOR_OML_H */
